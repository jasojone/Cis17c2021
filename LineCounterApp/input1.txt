/* 
 * File:   BloomFilter.h
 * Author: Jason
 *
 * Created on May 31, 2021, 6:42 PM
 */


#ifndef BLOOMFILTER_H
#define BLOOMFILTER_H
#include "Game.h"


/******************************************************************************\
  BloomFilter Class                                                           
  This Class will check to see if a player has played the game before by 
  storing all usernames in a bloom filter bit vector. If the user has played
  a welcome back will be displayed. If the user has not played the rules 
  menu option will be encouraged                                            
\******************************************************************************/
#define BFarrSize 512

class BloomFilter
{

private:
    bool *bitarray;
    void getBloomData();//reads the bloom filter form text file
    void pushBloomData();//pushes bloom data to the file
    
public:
    BloomFilter();
    ~BloomFilter();
    void setBFname(string s);
    // search the bloom filter for user case
    bool bfSearch(string s);
    // set the bloom filter in the event there is a new user case
    void bfPush(string s);
    unsigned int ELFHash(const std::string& str);
    unsigned int APHash(const std::string& str);
    };

    inline BloomFilter::BloomFilter()
    {
        bitarray = new bool[BFarrSize];
        for (int i = 0; i < BFarrSize; i++)
        bitarray[i] = false;
        getBloomData();
    }
    inline BloomFilter::~BloomFilter()
    {
        pushBloomData();
        delete[] bitarray;
    }

#endif /* BLOOMFILTER_H */
/* 
 * File:   Card.h
 * Author: Jason
 *
 * Created on April 1, 2021, 8:25 AM
 */

#ifndef CARD_H
#define CARD_H

#include <iostream>
#include <map>

using namespace std;
 /*****************************************************************************\
 * Card                                                                        *
 * The Card struct will contain the attributes of the card.                    *
 * Attributes: the cards suit, the power of the card and the cards ascii art.  *
 \*****************************************************************************/
struct Card
{
    string suit;    // cards suit 
    int cPower;     // power of the card to determine who will win the round
    Card() {}
    Card(string s, int p)// assign the power and suit when card is created
    {
        suit = s;
        cPower = p;
    }
    friend bool operator==(const Card& l, const Card& r)
    {
        return l.cPower == r.cPower;
    }
    // cardArt is the map with a nested map that contains cars ascii visual art
    // the outer map key is the suits outer maps value is another map who's key 
    // is the power of a card and the value is the art of the card. 
    map<string, map<int, string>> cardArt = 
    {
        {"CLUBS",
            {

                {2, ".------.\n|2   ♣|\n|  ()  |\n| ()() |\n|♣   2|\n`------'\n"},
                {3, ".------.\n|3   ♣|\n|  ()  |\n| ()() |\n|♣   3|\n`------'\n"},
                {4, ".------.\n|4   ♣|\n|  ()  |\n| ()() |\n|♣   4|\n`------'\n"},
                {5, ".------.\n|5   ♣|\n|  ()  |\n| ()() |\n|♣   5|\n`------'\n"},
                {6, ".------.\n|6   ♣|\n|  ()  |\n| ()() |\n|♣   6|\n`------'\n"},
                {7, ".------.\n|7   ♣|\n|  ()  |\n| ()() |\n|♣   7|\n`------'\n"},
                {8, ".------.\n|8   ♣|\n|  ()  |\n| ()() |\n|♣   8|\n`------'\n"},
                {9, ".------.\n|9   ♣|\n|  ()  |\n| ()() |\n|♣   9|\n`------'\n"},
                {10, ".------.\n|10  ♣|\n|  ()  |\n| ()() |\n|♣  10|\n`------'\n"},
                {11, ".------.\n|J   ♣|\n|  ()  |\n| ()() |\n|♣   J|\n`------'\n"},
                {12, ".------.\n|Q   ♣|\n|  ()  |\n| ()() |\n|♣   Q|\n`------'\n"},
                {13, ".------.\n|K   ♣|\n|  ()  |\n| ()() |\n|♣   K|\n`------'\n"},
                {14, ".------.\n|A   ♣|\n|  ()  |\n| ()() |\n|♣   A|\n`------'\n"}
            }
        },
        {"DIAMONDS", 
            {
                {2, ".------.\n|2   ♦|\n|  /\\  |\n|  \\/  |\n|♦   2|\n`------'\n"},
                {3, ".------.\n|3   ♦|\n|  /\\  |\n|  \\/  |\n|♦   3|\n`------'\n"},
                {4, ".------.\n|4   ♦|\n|  /\\  |\n|  \\/  |\n|♦   4|\n`------'\n"},
                {5, ".------.\n|5   ♦|\n|  /\\  |\n|  \\/  |\n|♦   5|\n`------'\n"},
                {6, ".------.\n|6   ♦|\n|  /\\  |\n|  \\/  |\n|♦   6|\n`------'\n"},
                {7, ".------.\n|7   ♦|\n|  /\\  |\n|  \\/  |\n|♦   7|\n`------'\n"},
                {8, ".------.\n|8   ♦|\n|  /\\  |\n|  \\/  |\n|♦   8|\n`------'\n"},
                {9, ".------.\n|9   ♦|\n|  /\\  |\n|  \\/  |\n|♦   9|\n`------'\n"},
                {10, ".------.\n|10  ♦|\n|  /\\  |\n|  \\/  |\n|♦  10|\n`------'\n"},
                {11, ".------.\n|J   ♦|\n|  /\\  |\n|  \\/  |\n|♦   J|\n`------'\n"},
                {12, ".------.\n|Q   ♦|\n|  /\\  |\n|  \\/  |\n|♦   Q|\n`------'\n"},
                {13, ".------.\n|K   ♦|\n|  /\\  |\n|  \\/  |\n|♦   K|\n`------'\n"},
                {14, ".------.\n|A   ♦|\n|  /\\  |\n|  \\/  |\n|♦   A|\n`------'\n"}
            }
        },
        {"HEARTS", 
            {
                {2, ".------.\n|2   ♥|\n| (\\/) |\n|  \\/  |\n|♥   2|\n`------'\n"},
                {3, ".------.\n|3   ♥|\n| (\\/) |\n|  \\/  |\n|♥   3|\n`------'\n"},
                {4, ".------.\n|4   ♥|\n| (\\/) |\n|  \\/  |\n|♥   4|\n`------'\n"},
                {5, ".------.\n|5   ♥|\n| (\\/) |\n|  \\/  |\n|♥   5|\n`------'\n"},
                {6, ".------.\n|6   ♥|\n| (\\/) |\n|  \\/  |\n|♥   6|\n`------'\n"},
                {7, ".------.\n|7   ♥|\n| (\\/) |\n|  \\/  |\n|♥   7|\n`------'\n"},
                {8, ".------.\n|8   ♥|\n| (\\/) |\n|  \\/  |\n|♥   8|\n`------'\n"},
                {9, ".------.\n|9   ♥|\n| (\\/) |\n|  \\/  |\n|♥   9|\n`------'\n"},
                {10, ".------.\n|10  ♥|\n| (\\/) |\n|  \\/  |\n|♥  10|\n`------'\n"},
                {11, ".------.\n|J   ♥|\n| (\\/) |\n|  \\/  |\n|♥   J|\n`------'\n"},
                {12, ".------.\n|Q   ♥|\n| (\\/) |\n|  \\/  |\n|♥   Q|\n`------'\n"},
                {13, ".------.\n|K   ♥|\n| (\\/) |\n|  \\/  |\n|♥   K|\n`------'\n"},
                {14, ".------.\n|A   ♥|\n| (\\/) |\n|  \\/  |\n|♥   A|\n`------'\n"}
            }
        },
        {"SPADES",
            {
                {2, ".------.\n|2   ♠|\n|  /\\  |\n| (__) |\n|♠   2|\n`------'\n"},
                {3, ".------.\n|3   ♠|\n|  /\\  |\n| (__) |\n|♠   3|\n`------'\n"},
                {4, ".------.\n|4   ♠|\n|  /\\  |\n| (__) |\n|♠   4|\n`------'\n"},
                {5, ".------.\n|5   ♠|\n|  /\\  |\n| (__) |\n|♠   5|\n`------'\n"},
                {6, ".------.\n|6   ♠|\n|  /\\  |\n| (__) |\n|♠   6|\n`------'\n"},
                {7, ".------.\n|7   ♠|\n|  /\\  |\n| (__) |\n|♠   7|\n`------'\n"},
                {8, ".------.\n|8   ♠|\n|  /\\  |\n| (__) |\n|♠   8|\n`------'\n"},
                {9, ".------.\n|9   ♠|\n|  /\\  |\n| (__) |\n|♠   9|\n`------'\n"},
                {10, ".------.\n|10  ♠|\n|  /\\  |\n| (__) |\n|♠  10|\n`------'\n"},
                {11, ".------.\n|J   ♠|\n|  /\\  |\n| (__) |\n|♠   J|\n`------'\n"},
                {12, ".------.\n|Q   ♠|\n|  /\\  |\n| (__) |\n|♠   Q|\n`------'\n"},
                {13, ".------.\n|K   ♠|\n|  /\\  |\n| (__) |\n|♠   K|\n`------'\n"},
                {14, ".------.\n|A   ♠|\n|  /\\  |\n| (__) |\n|♠   A|\n`------'\n"}
            }
        }
    };
};

#endif /* CARD_H */
/* 
 * File:   Deck.h
 * Author: Jason
 *
 * Created on April 1, 2021, 8:25 AM
 */
#ifndef DECK_H
#define DECK_H
#include "Player.h"
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <stack>
#include <list>
using namespace std;

 /*****************************************************************************\
 * Deck                                                                        *
 * The Deck class will contain the attributes of the deck of cards.            *
 * Attributes: a vector of cards, a string array with suits for map keys.      *
 \*****************************************************************************/
class Deck 
{
private:
    // The currDack is a vector of cards which will be used to populate the 
    // 52 cards that will be used for the game. A vector was used for the
    // purpose of random_shuffle 
    vector<Card> currDeck;
    // The suits are held in a list container to allow us to assign the 
    // 14 cards of each suit typ. A list was used to fulfill the requirements
    // of a list as well as iterators. 
    list<string> suits = {"CLUBS", "DIAMONDS", "HEARTS", "SPADES"};
    
public:
    Deck(); // default constructor will create the deck when instantiated. 
    void dealCards(Player &currPlayer); // deals the card 26 per player.
    void merge(vector<Card> &arr, int l, int m, int r);
    void mergeSort(vector<Card> &arr, int l, int r);
};
#endif /* DECK_H */
/* 
 * File:   Game.h
 * Author: Jason
 *
 * Created on April 1, 2021, 9:04 PM
 */

#ifndef GAME_H
#define GAME_H
#include <algorithm> 
#include <thread> 
#include <chrono>
#include <fstream>          
#include <iostream>
#include <ctime>
#include <cstdlib>
#include <limits>
#include <queue>
#include "Player.h"
#include "Card.h"
#include "Game.h"
#include "Deck.h"
#include "Player.h"
#include "ScoreTree.h"
#include "BloomFilter.h"
 /*****************************************************************************\
 * Game                                                                        *
 * This class is a designed to hold all the attributes of the game. This will  *
  * allow for the main function to maintain a minimalistic appearance.         *
 \*****************************************************************************/
class Game
{
public:
    // the default constructor will call the function that reads scores from 
    // the text file and populate the map to print the scores. 
    Game()
    {
        readScoresFromFile();
    }
    ~Game()
    {
        delete sBoard;
    }

    multimap<int, string> highScores; // high scores container.
    ScoreTree* sBoard;
    void displayWelcome(); // displays the welcome intro.
    void mainMenu(); // displays the main menu and begins to gain user input.
    void gameLoop(); // the main game loop.
    void rules(); // displays the rules. 
    double readInput(int userChoice); // checks if user input is valid for main menu.
    void countAces(Player p1);
    void war(Player &p1, Player &cpu, int &playCount, bool &gameOver); // runs the logic for war loop.
    // shuffles cards from won cards and puts them into the hand in play.
    void playerShuffleIn(Player &p1, Player &cpu); 
    void highScoresBoard(); // displays the score board.
    void printScoreRecords(Node* root); // will print the entire score records. 
    void readScoresFromFile(); // reads scores from the file and populates the score board multimap
    void writeScoresToFile(); // writes scores from the multimap to file 
    void displayWar(); // displays was acsii art to reduce redundancy. 
    // test function to count all cards in their respective containers. 
    void testCounters(Player p1, Player cpu, int playCount); 

};
#endif /* GAME_H */
/* 
 * File:   Player.h
 * Author: Jason
 *
 * Created on April 1, 2021, 8:25 AM
 */
 /*****************************************************************************\
 * This header will contain the players hands and the display of the card in   *
 * play                                                                        *
 \*****************************************************************************/
#ifndef PLAYER_H
#define PLAYER_H
#include "Card.h"
#include <stack>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

 /*****************************************************************************\
 * Player                                                                      *
 * The Player class will contain the attributes of the player.                 *
 * Attributes: players name string, hand in play stack, cards won vector,      *
 * war cards queue.                                                            *
 \*****************************************************************************/
class Player 
{
private:
    string playerName; // hold players name.
public:
    // hand in play used to pull cards from for each play a stack was used 
    // for its simple nature only the top card needs to be accessed. 
    stack<Card> handInPlay; 
    // cards won is used to hold all the cards won from battles and wars
    // a vector was used so that once the cards in hand in play run out
    // we can simply use an algorithm to shuffle the cards before returning
    // them to the hand in play. 
    vector<Card> cardsWon; 
    // the war queue is used to hold the cards offered for war as well as 
    // the cards that initiate the war in the first place. A queue was used
    // to fulfill the assignment requirements. 
    queue<Card> war;
    
    void displayTopCard(); // displays top card.
    void printHand(); // used to print the hand for testing.
    void shuffleIn(); // shuffles the cards won and returns them to the hand in play.
    void setName(string ); // setter for the player name.
    string getName(); // getter for the player name. 
};

#endif /* PLAYER_H */
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   ScoreTree.h
 * Author: Jason
 *
 * Created on May 31, 2021, 12:38 PM
 */

#ifndef SCORETREE_H
#define SCORETREE_H

struct Node
{
    int score;
    string name;
    Node *left;
    Node *right;

    Node(int fScore, string fName)
    {
        score = fScore;
        name = fName;
        left = NULL;
        right = NULL;
    }

    void insert(Node *player)
    {
        if (player->score < this->score)
        {
            if (this->left == NULL)
            {
                this->left = player;
            }
            else
            {
                this->left->insert(player);
            }
        }
        else
        {
            if (this->right == NULL)
            {
                this->right = player;
            }
            else
            {
                this->right->insert(player);
            }
        }
    }
};

class ScoreTree
{
private:
    Node* root;
public:
    ScoreTree()
    {
        root = NULL;
    }
    void insert(int score, string name)
    {
        if (root == NULL)
        {
            root = new Node(score, name);
        }
        else
        {
            Node* player = new Node(score, name);
            root->insert(player);
        }
    }
    //Node* getRoot()
    //{
    //    return root;
    //}
    void printScoreRecords()
    {
        printScoreRecords(root);
    }
    void printScoreRecords(Node* root)
    {
        if (root == NULL)
            return;
        printScoreRecords(root->left);
        cout << "Name: " << root->name << "\nScore:  " << root->score << endl <<endl;
        printScoreRecords(root->right);
    }
};


#endif /* SCORETREE_H */

/* 
 * File:   BloomFilter.cpp
 * Author: Jason
 *
 * Created on May 31, 2021, 6:43 PM
 */
#include "BloomFilter.h"
/******************************************************************************\
bloomFilterPush                                                           

\******************************************************************************/
bool BloomFilter::bfSearch(string s)
{
  return (bitarray[ELFHash(s) % BFarrSize] && bitarray[APHash(s) % BFarrSize]);
}

/******************************************************************************\
bloomFilterPush                                                           

\******************************************************************************/
void BloomFilter::bfPush(string s)
{
   bitarray[ELFHash(s) % BFarrSize] = true;
   bitarray[APHash(s) % BFarrSize] = true;
}

unsigned int BloomFilter::ELFHash(const std::string& str)
{
    unsigned int hash = 0;
    unsigned int x = 0;

    for (std::size_t i = 0; i < str.length(); i++)
    {
        hash = (hash << 4) + str[i];
        if ((x = hash & 0xF0000000L) != 0)
        {
            hash ^= (x >> 24);
        }
        hash &= ~x;
    }

    return hash;
}

unsigned int BloomFilter::APHash(const std::string& str)
{
    unsigned int hash = 0xAAAAAAAA;

    for (std::size_t i = 0; i < str.length(); i++)
    {
        hash ^= ((i & 1) == 0) ? ((hash << 7) ^ str[i] * (hash >> 3)) :
            (~((hash << 11) + (str[i] ^ (hash >> 5))));
    }

    return hash;
}

void BloomFilter::getBloomData()
{
    ifstream file ("bloomFilter.bin", ios::binary|ios::in);
    file.read(reinterpret_cast<char *>(bitarray), sizeof(bool) * BFarrSize);
    file.close();
}

void BloomFilter::pushBloomData()
{
    ofstream file ("bloomFilter.bin", ios::binary|ios::out);
    file.write(reinterpret_cast<char *>(bitarray), sizeof(bool) * BFarrSize);
    file.close();
}
/* 
 * File:   Deck.cpp
 * Author: Jason
 *
 * Created on April 4, 2021, 9:04 PM
 * 
 * 
 */
#include "Deck.h"

 /*****************************************************************************\
  Deck Constructor                                                            
  The default constructor will create the 52 cards using the card class       
  elements                                                                    
 \*****************************************************************************/
Deck::Deck()
    {
        // Due to the decks private variable of suits being a list an iterator
        // was used to traverses through the suits, there is a total of four 
        // suits traversing through the list from the begin and end will reach 4
        for (list<string>::iterator itr = suits.begin(); itr != suits.end(); itr++)
        {
            // traverses though the powers of each suit and populates the deck
            // with suited cards.
            for (int j = 2; j <= 14; j++)
            {
                // emplace is used over 
                currDeck.emplace_back(Card(*itr, j));
            }
        }
        // once the deck is populated it is then shuffled for play.
        
        //Sort using a recurisive mergeSort
        mergeSort(currDeck, 0, currDeck.size()-1);

        // using the random access iterator 
        random_shuffle(currDeck.begin(), currDeck.end());
    }

 /*****************************************************************************\
  dealCards                                                                   
  This function will take the deck of 52 cards and populate each players hand 
  with 26 cards each.                                                         
 \*****************************************************************************/
void Deck::dealCards(Player &currPlayer)
{
    // for loop deals the cards to each player 26 to each player
    for (int i = 0; i < 26; i++)
    {
        // pushes the cards to the hand in play form the deck then pops them 
        // off the current deck. 
        currPlayer.handInPlay.push(currDeck.back());
        currDeck.pop_back();
    }
}

/*****************************************************************************\
merge                                                                   
                                                          
\*****************************************************************************/
void Deck::merge(vector<Card> &arr, int l, int m, int r)
{
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp vectors 
    vector<Card> L(n1);
    vector<Card> R(n2);

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays back into arr[l..r]

    // Initial index of first subarray
    int i = 0;

    // Initial index of second subarray
    int j = 0;

    // Initial index of merged subarray
    int k = l;

    while (i < n1 && j < n2) {
        if (L[i].cPower <= R[j].cPower) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of
    // L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of
    // R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}


/*****************************************************************************\
mergeSort
 l is for left index and r is right index of the sub-array of arr to be sorted 


\*****************************************************************************/
void  Deck::mergeSort(vector<Card> &arr, int l, int r) {
    if (l < r)
    {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
/* 
 * File:   Game.cpp
 * Author: Jason
 *
 * Created on April 4, 2021, 9:04 PM
 * 
 * Game.cpp will contain the games main loop and all the games functions
 * Add:
 * graphs
 */
#include "Game.h"

/****************************************************************************\
mainMenu                                                                   
This function will display the main menu. The use will have options to     
play war, see the rules, check the score board and exit the game.          
Variables: userChoice holds the users menu choice, userName holds the user 
name for high scores,                                                      
\****************************************************************************/
void Game::mainMenu()
{
    srand(time(0)); // Random seed for the shuffle algorithm. 
    int userChoice = 0; // Sets the user choice outside the range of the menu.
    
    while(userChoice != 5) 
    {
        //Main menu output
        cout << "---------------------------\n";
        cout << "|        Main Menu        |\n";
        cout << "---------------------------\n";
        cout << "1) Play WAR\n";
        cout << "2) Rules\n";
        cout << "3) High Score Board\n";
        cout << "4) Score Records\n";
        cout << "5) Exit Game ";
        cout << string(3, '\n'); //moves menu up a bit from the bottom   
        
        // Takes user input for main menu uses input validation.
        userChoice = readInput(userChoice);

        // Switch statement handles the main menu.
        switch (userChoice)
        {
            case 1: // starts the game loop.
            {
                cout << "Lets play WAR!\n";
                gameLoop();
                break;
            }
            case 2: // display the rules.
            {
                rules();
                break;
            }
            case 3: // display the Score Board.
            {
                highScoresBoard();
                break;
            }
            case 4: // display the rules.
            {
                sBoard->printScoreRecords();
                //sBoard->printScoreRecords(sBoard->getRoot());
                //printScoreRecords(sBoard);
                break;
            }
            case 5: // end the game and exit.
            {
                cout << string(5, '\n');
                cout << "Thank you for playing,\n"<< endl;
                displayWar();
                break;
            }
        }
    }
}

/****************************************************************************\
gameLoop                                                                   
This function holds the game loop and logic for the game. The game loop    
will run on a do while loop with an end of game condition game over true    
\****************************************************************************/
void Game::gameLoop()
{
    // Deck class instantiation refer to Deck.h for build and implementation.
    Deck gameDeck; 
    
    // Creating the instance of the player and CPU player, refer to the 
    // Player.h for build and implementation.
    Player p1;
    Player cpu;
    
    // playCount hold the number of hands played for high scores.
    int playCount = 0;
    
    // gameOver bool controls the game over sequence, this is part of the 
    // do while conditions in the game loop.
    bool gameOver = false; 
    
    // userName holds the username for high scores this will be set to the 
    // playerName private variable in the Player class.
    string userName; 
    
    cout << "Enter your Name:\n";
    // clear the input buffer.
    cin.ignore();
    // gather the user input for the userName.
    getline(cin, userName);
    // create an instance of the Bloom filter
    BloomFilter BF;

    // if the username hash has set the bitvector then check the map to verify if 
    if (BF.bfSearch(userName)) {
        for (auto& it : highScores) {
            if (it.second == userName) {
                cout << "Welcome back " << userName << ", get ready for War!" << endl;
            }
        }
    }
    else {
        // push the username to the bloom filter 
        BF.bfPush(userName);
        cout << "Welcome, " << userName << " to War the Card game,\nPlease read the rules before playing." << endl;
    }
    

    // use the setter to set name.
    p1.setName(userName);
    
    
    
    cout << "Dealing Cards...\n\n";
    
    // dealCards() is called and deal the deck 26 cards to each player.
    gameDeck.dealCards(p1);
    // test by printing the hand to see if there are still 52 individual cards.
    //p1.printHand();

    gameDeck.dealCards(cpu);
    //cpu.printHand();    
    
    cout << "The Battle Begins!\n\n";
   
    // The do while loop is the main game loop that will contain all the game logic. 
    do
    {
        countAces(p1);
        // Output the card total for each player.
        cout << "You have " << p1.cardsWon.size()+p1.handInPlay.size() << " cards total\n";
        
        //p1.printHand(); for testing 
        cout << "The CPU has " << cpu.cardsWon.size()+cpu.handInPlay.size() << " cards total\n";
        //cpu.printHand(); for testing 
        // Test counters to work on the game loop. 
        //testCounters(p1, cpu, playCount);
        
        // shuffleIn will check currHand Size to see if any player still has 
        // cards on the stack to play with, if not shuffle the cardsWon and 
        // pop them onto the currHand stack for play.
        playerShuffleIn(p1, cpu);
        
        // Crates a new card instance that is a place holder for the top 
        // card of the current hand in play this will be used to push back 
        // the cards when won. Pulling the card off the deck and putting it 
        // on the table.
        Card p1Top = p1.handInPlay.top();
        Card cpuTop = cpu.handInPlay.top();        

        // This will display the cards in play. 
        cout << "Your Card:\n";
        p1.displayTopCard();
        
        cout << "VS\n"; 
        // count the hand this will be used for the high scores.
        playCount++;
        
        cout << "Computers Card:\n";
        cpu.displayTopCard();
        
        // if player 1's hand is the winning hand.
        if (p1Top.cPower > cpuTop.cPower)
        {
            cout << "You won the round!\n";
            cout << "Press Enter to continue\n";
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Taking your winnings.\n";
            
            // push the cards in play that are won onto the cardsWon pile.
            p1.cardsWon.push_back(p1Top);
            p1.cardsWon.push_back(cpuTop);
            // pop the cards off the hands in play.
            p1.handInPlay.pop();
            cpu.handInPlay.pop();
            // clear the screen.
            cout << string (100, '\n');
        }
        
        // if cpu wins the hand.
        else if (cpuTop.cPower > p1Top.cPower)
        {
            cout << "You lost the round.\n";
            cout << "Press Enter to continue\n";
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "CPU takes the winnings.\n";
            
            // push the cards in play that are won to the cpu cards won pile.
            cpu.cardsWon.push_back(p1Top);
            cpu.cardsWon.push_back(cpuTop);
            // pop the cards off the hands in play.
            p1.handInPlay.pop();
            cpu.handInPlay.pop(); 
            cout << string (100, '\n');         
        }
        
        // if the cards are equal then go to war.
        else
        {
            war(p1, cpu, playCount, gameOver);
        }
        
        // check to see if players have cards to play the game.
        if (p1.handInPlay.size() + p1.cardsWon.size() <= 1)
        {
        gameOver = true; // end game loop
        }

        else if (cpu.handInPlay.size() + cpu.cardsWon.size() <= 1)
        {
        gameOver = true; // end game loop
        }
    }

    // condition that ends the game loop if either player does not have 
    // enough cards to continue the game over loop is true.
    while (gameOver == false);

    if (p1.cardsWon.size() + p1.handInPlay.size() > 4)
    {
        // print the statistics of the game
        cout << "Congratulations "<< userName << " You won the game of WAR" << endl;
        cout << "This game took " << playCount << " hands to complete." << endl;
        // write the statistics to the multimap that holds the high scores to be 
        // written to the text file.
        highScores.insert(pair<int,string> (playCount, userName));
        sBoard->insert(playCount, userName);
        cout << "Thank you for playing WAR\n";
        cout << "Press Enter to return to main" << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }
    
    else
    {
        cout << "You lost the game of WAR" << endl;        
        cout << "This game took " << playCount << " hands to complete." << endl;
        highScores.insert(pair<int,string> (playCount, userName));
        sBoard->insert(playCount, userName);
        cout << "Thank you for playing WAR\n";
        cout << "Press Enter to return to main" << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }
    // calls the function that writes the scores to the text file. 
    writeScoresToFile();      
}

/****************************************************************************\
war                                                                        
This function hold the logic of a war instance. When the cards are equal   
the war function is called.                                                
\****************************************************************************/
void Game::war(Player &p1, Player &cpu, int &playCount, bool &gameOver)
{
    // The war queue will hold the face two war cards 
    // and the two face down cards
    // Push the war cards onto the war queue and pop them
    // off the hands to move onto the war offerings
    p1.war.push(p1.handInPlay.top());
    p1.handInPlay.pop();
    cpu.war.push(cpu.handInPlay.top());
    cpu.handInPlay.pop();

    // check if p1 has enough cards for war.
    if (p1.handInPlay.size() + p1.cardsWon.size() <= 2)
    {
    cout << "You do not have Cards to go to war with.\n" << "You must forfeit the game." << endl;
    gameOver = true; // end game loop.
    }

    // check if cpu has enough cards for war.
    else if (cpu.handInPlay.size() + cpu.cardsWon.size() <= 2)
    {
    cout << "The CPU has no Cards to go to war with.\n" << "The CPU must forfeit the Game." << endl;
    gameOver = true; // end game loop
    }
    
    if(gameOver == true)
        return;
    
    // Check current handsSize to see if any player still has cards 
    // to play with if not shuffle the cards won and repopulate 
    // the current hand stack
    playerShuffleIn(p1, cpu);

    // display war function
    displayWar();

    cout << "The offerings of war\n";

    // Two "cards" that will simply just be for display purpose
    for (int i = 0; i < 2; i++)
    {
        cout << "\n.------.\n| **** |\n| **** |"
            "\n| **** |\n| **** |\n`------'\n";
    }

    //Check currHand Size to see if any player still has cards to play with
    playerShuffleIn(p1, cpu);

    // Facedown will be pulled off the stack and the next cards will be
    // placed on for the next battle
    Card p1Top = p1.handInPlay.top();
    Card cpuTop = cpu.handInPlay.top(); 

    // Add the face down cards to the war queue  
    p1.war.push(p1Top);
    cpu.war.push(cpuTop);

    // pop off the face down cards form the current hand 
    p1.handInPlay.pop();
    cpu.handInPlay.pop();

    //Check currHand Size to see if any player still has cards to play with 
    playerShuffleIn(p1, cpu);

    // This is where the new face up cards are drawn to compare and display
    // to settle the war
    p1Top = p1.handInPlay.top();
    cpuTop = cpu.handInPlay.top(); 

    // Check curHand Size to see if any player still has cards to play with
    playerShuffleIn(p1, cpu);

    // print cards for the war
    cout << "Your Card for WAR:\n";
    p1.displayTopCard();
    cout << "VS\n\n";   
    playCount++;
    cout << "The CPU's Card for WAR:\n";
    cpu.displayTopCard();

    if (p1Top.cPower > cpuTop.cPower)
    {
        cout << "You won the WAR!\nTaking the spoils of WAR.\n";
        cout << "Press Enter to continue\n";
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << string (100, '\n');
        // take the winnings from the last play.
        p1.cardsWon.push_back(p1Top);
        p1.cardsWon.push_back(cpuTop);
        // take the winnings from the war queues.
        while(!p1.war.empty())
        {
            p1.cardsWon.push_back(p1.war.front());
            p1.war.pop();
        }

        while(!cpu.war.empty())
        {
            p1.cardsWon.push_back(cpu.war.front());
            cpu.war.pop();
        }
        // remove the last cards played.
        p1.handInPlay.pop();
        cpu.handInPlay.pop();
    }

    else if (cpuTop.cPower > p1Top.cPower)
    {
        cout << "You Lost the WAR!\nCPU takes the spoils of WAR.\n";
        cout << "Press Enter to continue\n";
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        cout << string (100, '\n');

        // cpu takes the winnings from the last play.
        cpu.cardsWon.push_back(p1Top);
        cpu.cardsWon.push_back(cpuTop);

        // cpu takes the winnings from the war queues.
        while(!p1.war.empty())
        {
            cpu.cardsWon.push_back(p1.war.front());
            p1.war.pop();
        }

        while(!cpu.war.empty())
        {
            cpu.cardsWon.push_back(cpu.war.front());
            cpu.war.pop();
        }
        // remove the last cards played.
        p1.handInPlay.pop();
        cpu.handInPlay.pop();
    }
    else
    {   // recursive war loop
        war(p1, cpu, playCount, gameOver);
    }         
}
/****************************************************************************\
readInput                                                                  
Takes the user input and tests it to see if its an integer within range.   
Precondition: int userChoice 0                                             
Postcondition: dependent upon the user input, valid options are 1,2,3,4    
\****************************************************************************/
double Game::readInput(int userChoice)
{
    // temporarily set choice to -1
    int choice = -1;
    // do while condition
    bool valid= false;
    
    do
    {
        cout << "Select your option and press enter.\n" << flush;
        cin >> choice;
        // if choice is an integer set loop condition to break and return the 
        // user selection.
        if (choice <=4 && choice > 0 && cin.good())
        {
            //user input choice was valid.
            valid = true;
        }
        else
        {
            //something went wrong, reset the buffer.
            cin.clear();
            // empty it
            cin.ignore(numeric_limits<streamsize>::max(),'\n');
            cout << "Invalid input, please select 1-4." << endl;
        }
    } while (!valid);

    return (choice);
}

/****************************************************************************\
countAces                                                                  
This function will count the number of aces that the player has. This will 
show the player that the aces may not be the determining factor of who     
will win the game of war.                                                  
\****************************************************************************/
void Game::countAces(Player p1)
{
    // create a temporary card that will be used for the count algorithm.
    Card tmpCard("CLUBS", 14);
    // the algorithm count was used here to count the number of Aces in the 
    // players cards won. 
    int tmp = count(p1.cardsWon.begin(), p1.cardsWon.end(), tmpCard);
    // then create a temporary stack to hold the actual stack to be used for
    // traversing through to add the aces that are in the hand. 
    stack<Card> tmpStack = p1.handInPlay;
    
    // use of the while loop to traverse through the temp stack and add all
    // the aces held to the count. 
    while (!tmpStack.empty())
    {
        if (tmpStack.top() == tmpCard) tmp++;
        tmpStack.pop();
    }
    // display the total aces at the players disposal.
    cout << "You Have " << tmp << " Aces" << endl;
}
/****************************************************************************\
rules                                                                      
This function will display the rules of the game                           
\****************************************************************************/
void Game::rules()
{
    
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    
    cout <<"-------------------------------THE RULES-------------------------------\n"
    "In the basic game there are two players and you use a standard 52 card\n"
    "pack. Cards rank as usual from high to low: A K Q J T 9 8 7 6 5 4 3 2.\n"
    "Suits are ignored in this game.\n\n"
     
    "--------------------------------THE DEAL--------------------------------\n"
    "Deal out all the cards, so that each player has 26. Players do not look\n"
    "at their cards, but keep them in a packet face down. The object of the\n"
    "game is to win all the cards.\n\n"
            
    "--------------------------------THE PLAY--------------------------------\n"   
    "Both players now turn their top card face up and put them on the table.\n"
    "Whoever turned the higher card takes both cards and adds them (face down)\n"
    "to the bottom of their packet. Then both players turn up their next card\n"
    "and so on. Once a player runs out of cards in their packet they will\n"
    "shuffle the cards won and use them to continue to play.\n\n"
            
    "--------------------------------THE WAR--------------------------------\n"       
    "If the turned up cards are equal there is a war. The tied cards stay on\n"
    "the table and both players play the next card of their pile face down\n"
    "and then another card face-up. Whoever has the higher of the new face-up\n"
    "cards wins the war and adds all six cards face-down to the bottom of\n"
    "their packet. If the new face-up cards are equal as well, the war \n"
    "continues: each player puts another card face-down and one face-up.\n"
    "The war goes on like this as long as the face-up cards continue to be\n"
    "equal. As soon as they are different the player of the higher card wins\n"
    "all the cards in the war.\n\n"
      
    "--------------------------------THE WIN--------------------------------\n"
    "The game continues until one player has all the cards and wins.\n"
    "This can take a long time. If you don't have enough cards to complete the\n"
    "war, you lose. If neither player has enough cards, the one who runs out\n"
    "first loses. If both run out simultaneously, it's a draw. Example: Players\n"
    "A and B both play sevens, so there is a war. Each player plays a card face\n"
    "down, but this is player B's last card. Player A wins, since player B does\n"
    "not have enough cards to fight the war.\n\n" 
            
    "--------------------------------SCOREBOARD--------------------------------\n"
    "The scores will be kept based on play counts regardless of win or loss.\n"
    "There will be two top ten brackets. One for the longest game which took\n"
    "the most hands to complete. And another for the shortest game which took\n"
    "the least amount of hands to top ten least hands to complete a game.\n\n" 
    "Press enter to continue\n" << endl;
    
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

/****************************************************************************\
compMap                                                                    
This function will compare two pairs and return the result of the smaller  
of the two                                                                 
\****************************************************************************/
bool compMap(pair<int,string> a, pair<int,string> b)
{
    return a.first < b.first;
}

/****************************************************************************\
highScoresBoard                                                                 
This function will display the top ten shortest and longest games                           
\****************************************************************************/
void Game::highScoresBoard()
{
    cout << string (100, '\n');
    
    // declare two maps that will be used to implement the max and min algorithm
    // two iterators that are being used are bidirectional and the compMap function
    pair<int, string> max = *max_element(highScores.begin(),highScores.end(), compMap);
    pair<int, string> min = *min_element(highScores.begin(),highScores.end(), compMap);
    cout << "The Hall of Fame:" << endl;
    cout << "Longest Game of all Time" << endl;
    // print the name ans the score
    cout << max.second << ": "<< max.first << endl << endl;
    cout << "Shortest Game of all Time" << endl;
    cout << min.second << ": "<< min.first << endl << endl;
    
    int count = 0;
    cout << "The 10 Longest Games:" << endl;
    // The for loop will traverse the list from the end of the list to a count 
    // of 10 this will display the top ten highest hand count games. In order 
    // to do this a reverse_iterator is used to start at the end of the multi map.
    for (multimap<int, string>::reverse_iterator itr = highScores.rbegin(); count < 10; itr++, count++)
    {
        cout << "Name: " << itr->second << endl;
        cout << "Score: " << itr->first << endl << endl;
    }
    
    count = 0;
    cout << "The 10 Shortest Games:" << endl;
    // The for loop will traverse the list from the beginning of the list to a count 
    // of 10 this will display the top ten lowest hand count games. In order 
    // to do this a iterator is used to start at the beginning of the multi map.
    for (multimap<int, string>::iterator itr = highScores.begin(); count < 10; itr++, count++)
    {
        cout << "Name: " << itr->second << endl;
        cout << "Score: " << itr->first << endl << endl;
    }
}
/****************************************************************************\
 scoreBoard
 This function will display the top ten shortest and longest games
\****************************************************************************/


/****************************************************************************\
playerShuffleIn 
This function is called periodically in the game to check if the player/cpu
has depleted the cards in their hand in play. If the stack in play is      
empty the function calls shuffle in (part of the Player class) which       
shuffles the cards won pile and moves it to the hand in play.              
Precondition: hand in play state                                           
Postcondition: if hand in play is not 0 same, otherwise repopulates the    
hand in play with cards won shuffled.                                      
\****************************************************************************/
void Game::playerShuffleIn(Player &p1, Player &cpu)
{
    // if player hand is 0 call shuffleIn
    if (p1.handInPlay.size() == 0)
    {
        p1.shuffleIn();
    }

   // if cpu hand is 0 call shuffleIn
   if (cpu.handInPlay.size() == 0)
    {
       cpu.shuffleIn();
    } 
}

/****************************************************************************\
readScoresFromFile                                                         
This function is called when the user selects the score board option on    
the main menu. When called it will read the contents from the save file    
and populate the high scores multimap                                      
\****************************************************************************/
void Game::readScoresFromFile()
{
    ifstream inFile("scoreBoard.txt");
    sBoard = new ScoreTree();
    
    if(inFile.is_open())
    {
        // Holds the line being processed from the file.
        string curLine;
        
        // traverses the file getting one line at a time until reaching the end.
        while(getline(inFile, curLine))
        {
            // points to the current char of the current line.
            int start = 0;
            
            // sets the stop at the comma 
            string del = ",";
            
            // finds the location of the comma
            int end = curLine.find(del);  
            
            // turns the string (score) back into an int, then creates a 
            // substring from start to comma.
            int curScore = stoi(curLine.substr(start, end - start));
            // moves the start to the char after the comma (name)
            start = end + del.size();
            
            // the new end will look for another comma
            end = curLine.find(del, start);
            
            // fills the name using the subsrting from the new start location to
            // the end of the line. 
            string curName = curLine.substr(start, end - start);
            
            // Populate the map from the files saved scores.
            pair<int, string> tmp = make_pair(curScore, curName);
            highScores.insert(tmp);    

            sBoard->insert(curScore, curName); 
        }
    }
    else 
    {
        cout << "File is not open." << endl;
    }
    
    inFile.close();
}

/****************************************************************************\
writeScoresFromFile                                                        
This function is called when a game has ended and a new score needs to be   
saved.                                                                     
\****************************************************************************/
void Game::writeScoresToFile()
{
    ofstream outFile("scoreBoard.txt");
  
    // Execute a loop If file successfully opened
    if (outFile.is_open())
    {
        // using an iterator here to traverser though the map in its entirety  to write the 
        // scores to the text file. 
        for(multimap<int, string>::iterator itr = highScores.begin(); itr != highScores.end(); itr++)
        {
            outFile << itr->first << "," << itr->second << endl;
        }
    }
    
    else
    {
       cout << "File is not open." << endl;
    }
    outFile.close();
}

/****************************************************************************\
sortTree
\****************************************************************************/
/*void Game::printScoreRecords(ScoreTree *root)
{
    if (root == NULL)
        return;
    printScoreRecords(root->left);
    cout << root->name << "  " << root->score;
    printScoreRecords(root->right);
}*/

/****************************************************************************\
displayWar                                                                 
This function will simply display the word war this is used in the welcome 
message and the war game loop.                                               
\****************************************************************************/
void Game::displayWar()
{
    cout << "\t`7MMF'     A     `7MF' db      `7MM''''Mq.    \n";
    cout << "\t  `MA     ,MA     ,V  ;MM:       MM   `MM.    \n";
    cout << "\t   VM:   ,VVM:   ,V  ,V^MM.      MM   ,M9     \n";
    cout << "\t    MM.  M' MM.  M' ,M  `MM      MMmmdM9      \n";
    cout << "\t    `MM A'  `MM A'  AbmmmqMA     MM  YM.      \n";
    cout << "\t     :MM;    :MM;  A'     VML    MM   `Mb.    \n";
    cout << "\t      VF      VF .AMA.   .AMMA..JMML. .JMM.   \n\n";
}

/****************************************************************************\
displayWelcome                                                             
This function will simply display the welcome screen and message.            
\****************************************************************************/
void Game::displayWelcome()
{
    cout << string(50, '\n');
    cout <<"`7MMF'     A     `7MF'     `7MM                                                  mm                 \n";
    cout <<"  `MA     ,MA     ,V         MM                                                  MM                 \n";
    cout <<"   VM:   ,VVM:   ,V .gP\"Ya   MM  ,p6\"bo   ,pW\"Wq.`7MMpMMMb.pMMMb.  .gP\"Ya      mmMMmm ,pW\"Wq.  \n"; 
    cout <<"    MM.  M' MM.  M',M'   Yb  MM 6M'  OO  6W'   `Wb MM    MM    MM ,M'   Yb       MM  6W'   `Wb      \n";
    cout <<"    `MM A'  `MM A' 8M''''''  MM 8M       8M     M8 MM    MM    MM 8M''''''       MM  8M     M8      \n";
    cout <<"     :MM;    :MM;  YM.    ,  MM YM.    , YA.   ,A9 MM    MM    MM YM.    ,       MM  YA.   ,A9      \n";
    cout <<"      VF      VF    `Mbmmd'.JMML.YMbmd'   `Ybmd9'.JMML  JMML  JMML.`Mbmmd'       `Mbmo`Ybmd9'       \n";
    this_thread::sleep_for (chrono::seconds(1));
    cout << string(100, '\n');

    displayWar();
    this_thread::sleep_for (chrono::seconds(1));
    cout << string(100, '\n');

    cout << "\t  mm   `7MM                  \n";
    cout << "\t  MM     MM                  \n";
    cout << "\tmmMMmm   MMpMMMb.  .gP\"Ya   \n";
    cout << "\t  MM     MM    MM ,M'   Yb   \n";
    cout << "\t  MM     MM    MM 8M''''''   \n";
    cout << "\t  MM     MM    MM YM.    ,   \n";
    cout << "\t  `Mbmo.JMML  JMML.`Mbmmd'   \n\n";

    cout << "   .g8'''bgd                      `7MM      .g8'''bgd       \n";
    cout << " .dP'     `M                        MM    .dP'     `M       \n";
    cout << " dM'       ` ,6'Yb.  `7Mb,od8  ,M''bMM    dM'       `  ,6\"Yb. `7MMpMMMb.pMMMb.  .gP\"Ya  \n";
    cout << " MM         8)   MM    MM' \"',AP    MM    MM          8)   MM   MM    MM    MM ,M'   Yb  \n";
    cout << " MM.         ,pm9MM    MM    8MI    MM    MM.    `7MMF',pm9MM    MM    MM    MM 8M''''''  \n";
    cout << " `Mb.     ,'8M   MM    MM    `Mb    MM    `Mb.     MM 8M   MM    MM    MM    MM YM.    ,  \n";
    cout << "   `''bmmmd' `Moo9^Yo..JMML.   `Wbmd'MML. `''bmmmdPY  `Moo9^Yo..JMML  JMML  JMML.`Mbmmd'  \n\n";
    this_thread::sleep_for (chrono::seconds(1));
    cout << string(100, '\n');
}
/****************************************************************************\
testCounters                                                               
This function is called to test the specific number of cards each container
has. This was used for testing to validate the game loop logic.            
\****************************************************************************/
void testCounters(int playCount, Player p1, Player cpu)
{
        // print play count
        cout << "Play count " << playCount << endl;
        // print card count held in player's stack in play.
        cout << "Your hand in play " << p1.handInPlay.size() << '\n';
        // print the card count in player's pile of won cards.
        cout << "your winnings " << p1.cardsWon.size() << '\n';
        // print card count held in cpu's stack in play.
        cout << "CPU's hand in play " << cpu.handInPlay.size() << '\n';
        // print the card count in cpu's pile of won cards.
        cout << "CPU's winnings " << cpu.cardsWon.size() << '\n';
        // print the card count in the war queue.
        cout << "WAR queue " << p1.war.size() + cpu.war.size() << endl;
        // add all the cards up and print them.
        cout << "Total cards in play " << p1.cardsWon.size()+p1.handInPlay.size() + cpu.cardsWon.size() + cpu.handInPlay.size() + p1.war.size() + cpu.war.size() << '\n';
        // print the suit, value and ascii art for all card held by player. 
        cout << "Your Cards" << endl;
        p1.printHand();
        // print the suit, value and ascii art for all card held by cpu. 
        cout << "cpu's cards" << endl;
        cpu.printHand();   
}

 /* 
 * File:   main.cpp
 * Author: Jason Jones
 * Created on April 01, 2021, 10:14 AM
 * 
 * Cis17c Project1.0 WAR
 * 
 /*****************************************************************************\
 * This program will consist of the card game War. One of my favorite card     *
 * games growing up War has a special place in my memories. This program will  *
 * demonstrate the use of concepts in the Object Orientated methodology of     *
 * programming and the use of the Standard Template Library.                   *
 \*****************************************************************************/

#include "Card.h"
#include "Player.h"
#include "Deck.h"
#include "Game.h"

int main(int argc, char** argv) 
{
    
    // Creates a new games instance.
    Game curGame;
    // Display the welcome ASCII art message.
    curGame.displayWelcome();
    // Calls the main menu for the game. 
    curGame.mainMenu();
    // Exit the program
    return 0;
}
/* 
 * File:   Player.h
 * Author: Jason
 *
 * Created on April 1, 2021, 8:25 AM
 */
#include "Player.h"

  /****************************************************************************\
  * displayTopCard                                                             *
  * This function will display the top card in play. It will use an if         *
  * statement to print the text description of the card. After the text we     *
  * will print the ascii art with subscript random access operators.           *
  \****************************************************************************/
void Player::displayTopCard()
{
    Card topCard = handInPlay.top();
    if (topCard.cPower < 11)
    {
        cout << topCard.cPower << " of " <<topCard.suit << endl;
    }

    else if (topCard.cPower == 11)
    {
        cout << "Jack" << " of " <<topCard.suit << endl;
    }

    else if (topCard.cPower == 12)
    {
        cout << "Queen" << " of " <<topCard.suit << endl;
    }

    else if (topCard.cPower == 13)
    {
        cout << "King" << " of " <<topCard.suit << endl;
    }

    else if (topCard.cPower == 14)
    {
        cout << "Ace" << " of " <<topCard.suit << endl;
    }
    cout << topCard.cardArt[topCard.suit][topCard.cPower] << endl;
    //
}

  /****************************************************************************\
  * readInput                                                                  *
  * Takes the user input and tests it to see if its an integer within range.   *
  * Precondition: int userChoice 0                                             *
  * Postcondition: dependent upon the user input, valid options are 1,2,3,4    *
  \****************************************************************************/
void Player::printHand()
{
    // creating a temporary clone of the stack of cards.
    stack<Card> tmp = this->handInPlay;
    
    // traverses though the entire list untill its empty.
    while (!tmp.empty())
    {
    Card topCard = tmp.top();
    cout << topCard.cardArt[topCard.suit][topCard.cPower] << endl;
    cout << topCard.cPower << " of " <<topCard.suit << endl;
    tmp.pop();
    }
}

  /****************************************************************************\
  * shuffleIn                                                                  *
  * This function is called periodically in the game to check if the player/cpu*
  * has depleted the cards in their hand in play. If the stack in play is      *
  * empty the function calls shuffle in (part of the Player class) which       *
  * shuffles the cards won pile and moves it to the hand in play.              *
  * Precondition: hand in play state                                           *
  * Postcondition: if hand in play is not 0 same, otherwise repopulates the    *
  * hand in play with cards won shuffled.                                      *
  \****************************************************************************/
void Player::shuffleIn()
{
    // shuffles the cards from beginning to end
    random_shuffle(cardsWon.begin(), cardsWon.end());
    
    // populates the hand in play with the freshly shuffled card. 
    // a for loop traverses through the entire won cards. 
    for (int i = cardsWon.size(); i > 0; i--)
    {
        handInPlay.push(cardsWon.back());
        cardsWon.pop_back();
    }
}

  /****************************************************************************\
  * setName                                                                    *
  * a setter to set a private variable of the user name.                       *
  \****************************************************************************/
void Player::setName(string outName)
{
    playerName = outName;
}

  /****************************************************************************\
  * getName                                                                    *
  * a getter for the playerName.                                               *
  \****************************************************************************/
string Player::getName()
{
    return playerName;

}






